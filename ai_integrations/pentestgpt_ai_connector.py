# Devin/ai_integrations/pentestgpt_ai_connector.py

import os
import time
import json
import requests # Using requests library for hypothetical HTTP calls
from typing import Dict, Any, List, Optional, Union

# --- Constants ---
# These should ideally come from config/ai_config.yaml or environment variables
# Using placeholders for environment variable names
DEFAULT_PENTESTGPT_API_URL = os.environ.get("PENTESTGPT_API_URL", "http://localhost:8081/pentestgpt/api") # Example URL
DEFAULT_PENTESTGPT_API_KEY = os.environ.get("PENTESTGPT_API_KEY") # Example API Key
DEFAULT_TIMEOUT_SECONDS = 180 # Potentially longer timeout for complex analysis
MAX_RETRIES = 2
INITIAL_RETRY_DELAY_SECONDS = 2

class PentestGPTConnector:
    """
    Conceptual connector for interacting with a hypothetical "PentestGPT" AI service,
    specialized for penetration testing tasks like analyzing scan results,
    suggesting exploits, and interpreting tool outputs.

    *** Assumes a hypothetical REST API exists for PentestGPT. ***
    """

    def __init__(self, api_url: Optional[str] = None, api_key: Optional[str] = None):
        """
        Initializes the PentestGPTConnector.

        Args:
            api_url (Optional[str]): The base URL for the PentestGPT API. Uses default if None.
            api_key (Optional[str]): API key for authentication. Uses default if None.
                                     *** Handle keys securely via env vars or secrets manager. ***
        """
        self.api_url = api_url or DEFAULT_PENTESTGPT_API_URL
        self.api_key = api_key or DEFAULT_PENTESTGPT_API_KEY
        if not self.api_key:
            print("WARNING: PentestGPT API key not provided or found in environment (PENTESTGPT_API_KEY). Calls may fail.")
        print(f"PentestGPTConnector initialized (API URL: {self.api_url})")

    def _prepare_headers(self) -> Dict[str, str]:
        """Prepares headers, including authentication if an API key is present."""
        headers = {"Content-Type": "application/json"}
        if self.api_key:
            headers["Authorization"] = f"Bearer {self.api_key}" # Example Bearer token auth
            # Or use a different scheme like "X-API-Key": self.api_key
        return headers

    def _send_request(self, endpoint: str, payload: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Internal helper to send requests with retry logic."""
        url = f"{self.api_url}/{endpoint.strip('/')}"
        headers = self._prepare_headers()
        current_retry = 0

        while current_retry <= MAX_RETRIES:
            try:
                print(f"  - Sending request to PentestGPT API: {url} (Attempt {current_retry+1})")
                response = requests.post(
                    url,
                    headers=headers,
                    json=payload,
                    timeout=DEFAULT_TIMEOUT_SECONDS
                )
                response.raise_for_status() # Check for HTTP errors
                print("    - Request successful.")
                return response.json()

            except requests.exceptions.RequestException as e:
                print(f"    - Error during PentestGPT API request: {e}")
                error_code = e.response.status_code if e.response is not None else None
                # Retry on server errors or rate limits (hypothetical codes)
                if error_code in [429, 500, 503, 504] and current_retry < MAX_RETRIES:
                    delay = (INITIAL_RETRY_DELAY_SECONDS * (2 ** current_retry)) + random.uniform(0, 1)
                    print(f"      - Retrying after {delay:.2f} seconds...")
                    time.sleep(delay)
                    current_retry += 1
                else:
                    return None # Failed or non-retryable error
            except Exception as e:
                 print(f"    - Unexpected error sending request: {e}")
                 return None # Fail on other errors

        print(f"  - Error: Failed to get response from PentestGPT API after {MAX_RETRIES} retries.")
        return None

    # --- Specific Pentesting Task Methods ---

    def analyze_scan_results(self, tool_name: str, scan_output: Union[str, Dict], context: Optional[Dict] = None) -> Optional[Dict[str, Any]]:
        """
        Sends scan results (e.g., Nmap, Burp) to PentestGPT for analysis.

        Args:
            tool_name (str): The name of the tool that generated the output (e.g., "nmap", "burpsuite").
            scan_output (Union[str, Dict]): The raw output (text) or structured output (dict).
            context (Optional[Dict]): Additional context (e.g., target scope, objectives).

        Returns:
            Optional[Dict[str, Any]]: Parsed analysis from PentestGPT, potentially including
                                      identified vulnerabilities, interesting findings, next steps.
                                      Example: {'summary': '...', 'vulnerabilities': [...], 'next_steps': [...]}
        """
        print(f"\nAnalyzing scan results from '{tool_name}' using PentestGPT...")
        payload = {
            "task": "analyze_scan",
            "tool": tool_name,
            "output": scan_output,
            "context": context or {}
        }
        # Hypothetical endpoint name
        response_data = self._send_request("analyze", payload)

        if response_data and response_data.get("status") == "success":
            print("  - Analysis successful.")
            return response_data.get("analysis_result", {})
        else:
            print("  - Analysis failed or returned unexpected format.")
            return None

    def suggest_exploits(self, vulnerability_info: Dict[str, Any], target_info: Optional[Dict] = None) -> Optional[List[Dict]]:
        """
        Asks PentestGPT for potential exploits based on identified vulnerability info.

        Args:
            vulnerability_info (Dict[str, Any]): Details about the vulnerability
                                                 (e.g., {'cve': 'CVE-XXXX-YYYY', 'service': 'apache', 'version': '2.4.x'}).
            target_info (Optional[Dict]): Information about the target system (OS, architecture).

        Returns:
            Optional[List[Dict]]: A list of suggested exploits, possibly with confidence scores or commands.
                                   Example: [{'exploit_name': '...', 'confidence': 0.8, 'reference': '...'}]
        """
        print(f"\nSuggesting exploits for vulnerability using PentestGPT...")
        payload = {
            "task": "suggest_exploits",
            "vulnerability": vulnerability_info,
            "target": target_info or {}
        }
        response_data = self._send_request("suggest", payload)

        if response_data and response_data.get("status") == "success":
            suggestions = response_data.get("exploit_suggestions", [])
            print(f"  - Received {len(suggestions)} exploit suggestions.")
            return suggestions
        else:
            print("  - Failed to get exploit suggestions.")
            return None

    def generate_pentest_plan(self, scope: List[str], objectives: List[str], constraints: Optional[List[str]] = None) -> Optional[Dict[str, Any]]:
        """
        Asks PentestGPT to generate a high-level penetration testing plan.

        Args:
            scope (List[str]): List of targets/networks in scope.
            objectives (List[str]): Goals of the penetration test.
            constraints (Optional[List[str]]): Any limitations or rules of engagement.

        Returns:
            Optional[Dict[str, Any]]: A structured plan (e.g., phases, tools, methodologies).
                                       Example: {'plan_summary': '...', 'phases': [{'name': 'Recon', 'steps': [...]}]}
        """
        print("\nGenerating pentest plan using PentestGPT...")
        payload = {
            "task": "generate_plan",
            "scope": scope,
            "objectives": objectives,
            "constraints": constraints or []
        }
        response_data = self._send_request("plan", payload)

        if response_data and response_data.get("status") == "success":
            print("  - Plan generation successful.")
            return response_data.get("plan", {})
        else:
            print("  - Failed to generate plan.")
            return None

    def ask_pentest_question(self, question: str, context: Optional[Dict] = None) -> Optional[str]:
        """
        Sends a natural language question related to pentesting to PentestGPT.

        Args:
            question (str): The user's question.
            context (Optional[Dict]): Any relevant context (e.g., current task, previous findings).

        Returns:
            Optional[str]: The textual answer from PentestGPT.
        """
        print("\nAsking PentestGPT a question...")
        payload = {
            "task": "ask_question",
            "question": question,
            "context": context or {}
        }
        response_data = self._send_request("ask", payload)

        if response_data and response_data.get("status") == "success":
            print("  - Received answer.")
            return response_data.get("answer", "No answer content found.")
        else:
            print("  - Failed to get answer.")
            return None


# Example Usage (conceptual)
if __name__ == "__main__":
    print("\n--- PentestGPT Connector Example (Conceptual) ---")

    # IMPORTANT: Set PENTESTGPT_API_URL and PENTESTGPT_API_KEY environment variables
    #            if this were connecting to a real (even mock) external service.
    if not os.environ.get("PENTESTGPT_API_KEY"):
        print("\nWARNING: PENTESTGPT_API_KEY environment variable not set.")
        print("         The following example uses a dummy key and expects calls to fail/return None.")
        connector = PentestGPTConnector(api_key="DUMMY_PENTESTGPT_KEY") # Use dummy key for example
    else:
         connector = PentestGPTConnector() # Reads from environment

    # Example 1: Analyze hypothetical Nmap output
    nmap_output_example = """
    Starting Nmap 7.91 ( https://nmap.org ) at ...
    Nmap scan report for example.com (93.184.216.34)
    Host is up (0.011s latency).
    Not shown: 998 filtered ports
    PORT    STATE SERVICE VERSION
    80/tcp  open  http    Apache httpd 2.4.41 ((Ubuntu))
    443/tcp open  ssl/http Apache httpd 2.4.41 ((Ubuntu))
    """
    analysis = connector.analyze_scan_results(tool_name="nmap", scan_output=nmap_output_example)
    if analysis:
        print("\nScan Analysis Result (Conceptual):")
        print(json.dumps(analysis, indent=2))
    else:
        print("\nScan Analysis failed (as expected with dummy key/URL).")

    # Example 2: Suggest exploits
    vuln_info = {'service': 'apache', 'version': '2.4.41', 'port': 80}
    exploits = connector.suggest_exploits(vulnerability_info=vuln_info)
    if exploits:
        print("\nExploit Suggestions (Conceptual):")
        print(json.dumps(exploits, indent=2))
    else:
         print("\nExploit suggestion failed.")

    # Example 3: Generate plan
    plan = connector.generate_pentest_plan(scope=["example.com", "192.168.1.0/24"], objectives=["Find web vulnerabilities", "Check for default credentials"])
    if plan:
        print("\nGenerated Plan (Conceptual):")
        print(json.dumps(plan, indent=2))
    else:
        print("\nPlan generation failed.")

    # Example 4: Ask question
    answer = connector.ask_pentest_question("What are common techniques to bypass WAF?")
    if answer:
        print("\nAnswer to question (Conceptual):")
        print(answer)
    else:
        print("\nAsking question failed.")


    print("\n--- End Example ---")
